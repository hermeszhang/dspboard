naming convention: 
to make a function global, also name it as
filename.functionname
and then .global that symbol

note that all function names use underscores, and jump points within
them use .dots


   
   how to store outputs?
   obvious output buffers, sure -- but then how to DMA? parallel port can't do chained DMA... well, what we really want are 

      


Pcode pending interrupt for new samples:

there are global no-trigger and lookback values

Upon getting a trigger, we want to say:
   don't re-trigger for n samples; this can be degremented and checked every sample
   wait another m samples to record. 
   


Generic configuration read and write : ---------------------------------

40 : Read config parameter
41 : write config parameter

 For writing, things are indicated above. For reading, we use the Target and Addr similarly, but return the data in a manner that makes sense (i.e. the similar data words) to the SOURCE device. 


write filter coefficients: 
    TARGET = 0x10 : FIR FILTER for spike channel 1
         0x11 : FIR FILTER for spike channel 2
	 0x12 : FIR FILTER for spike channel 3
	 0x13 : FIR FILTER for spike channel 4
	 0x14 : FIR FILTER for constant chan
    ADDR  =  coefficent number [0..255]
    DW0 = word that goes at ADDR, IEEE 32-bit foo
    DW1 = word that goes at ADDR+1, "

write filter lengths:
    TARGET = 0x20
    ADDR = filter length target (0 = spike 1, 3 = spike 4, 5 = cont)
    DW0[7:0] = length, unsigned int

write filter IDs:
    TARGET = 0x21
    ADDR = filter for chan
    DW0[15:0] = unique 16-bit filter ID

change spike parameters: 
    TARGET = 0x23 : spike length
       DW0[7:0] = unsigned spike length
    TARGET = 0x24 : notriggerlen
       DW0[7:0]   : length of no trigger period 
    TARGET = 0x25 : posttriglen
       DW0[7:0] : length of post-trigger period


change cont parms
    TARGET = 0x26 : downsampling ratio for continuous
         DW0[3:0]: downsampling ratio
    TARGET = 0x27 : number of samples to output per continuous frame
	 DW0[15:0] : actual number 




42: Enable spike acquisition interrupt
    flushes buffers, etc. 
43: disable spike acquisition interrupt
44 : events that change acq board settings:
// hardware parameters:
   when we're done changing a hardware parameter, we send a tetrode state broadcast event. Or something; still not quite sure. 
hardware parameters are funny. See, there could be some arbitrary amount of time between when we say "change" and when it actually changes; 

   if CMDPENDING < 0  then no pending events
      CMDPENDING = CMDID++
   else
      generate error!
   end if; 
      
   
   TARGET = 0x0 : channel gain on acq board
         ADDR = channel number
         DW0[3:0] = gain setting on board
   TARGET = 0x1 : HW filter on board
	 ADDR = channel number
         DW0[1:0] = channel 
   TARGET = 0x2 Input selection for continuous channel
	 DW0[1:0] = channel

   the resulting error will be set back to whoever sent this
   and we will give the target, addr, and command that failed
   with error "CMDPENDING"



every time the acqboard state changes, we send out a full broadcast frame with "updated acqboard state.
45: query acqboard settings



-----------------------------------------------------------------------------
BOOTING
-----------------------------------------------------------------------------
or, how to make my own loader kernel. 
We know that on startup, 1024 bytes (256 instruction words?) will be loaded into the device. 

Somewhat oddly, the docs seem to suggest that the reading actually begins externally at 0x000, and internally at 0x80000. So the loader really will have to over-write itself. 

But! but! 
we can do the following: essentially move the location of the loader kernel to the last 100 instructions in memory. This will of course be a total mindfuck for anyone who ever wants to use that space, but we make sure our linker won't let us put code there anyway. 

Note that the boot process loads 256 ops to 0x80000, but then when done vectors to 0x80050, the PP interrupt location; thus we need to KEEP AN RTI AT 0x80050!!! which will then return execution to 0x80005. 


Note that all instructions here must be PC-relative, otherwise, ouch! 


1. load in kernel
2. kernel copies kernel to last 100 instructions (600 bytes) of program memory
3. transferrs control to there
4. read in MyID
5. reads in events to write various locations in memory
   because boot code is so mission-critical, each written-in byte will
   be replied to



To generate the DSP code we execute
elfspl12k.exe -ram -f S3 -pm -o DSPboard.S3 DSPboard.dxe
where dxe is the executable format. 
Note that this creates six files, with DSPboard.s_0 containing all of the LSBytes, and DSPboard.s_5 the MSBs. 

We've created the readS3 class which , when passed an S3 file base name, will parse all necessary files. We can then request a name, which will return a map, whcih we can iterate over to build events. 

Note that our boot memory is stored from [0x84100, 0x84200).

to transfer words from PM to PM, use:
px = pm(oldloc)
pm(newloc) = px; 


then we loop for memory write events:
event in:
   ID = 0x05
   dw0 = address to write - 0x80000
   dw1 = lower two words
   dw2 = middle two words
   dw3 = upper two words
Event out:
   send to : original sender
   ID = 0x06
   SENDER = MYID
   dw0-dw3: identical to those originally sent

if we get an event of ID 0x7 then we're done!
 


 

