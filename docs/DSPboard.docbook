<?xml version="1.0" ?>
<article>
  <articleinfo>
    <title>The SOMA DSPboard</title>
    <author>
      <firstname>Eric</firstname>
      <surname>Jonas</surname>
    </author>
  </articleinfo>
  <section id="DSPboard.intro">
    <title>The DSPboard</title>
    <para> The Soma DSPboard is the computational and signal
    processing core of the Soma system. The DSPboard is responsible
    for decoding the optical Acquisiton Board data stream, performing
    application-specific filtering and processing on the incoming
    data, and passing the resulting data onto the Data bus. The DSP
    Board also maintains tetrode state, and provides an event bus
    interface for Acquisition board parameters.
    </para>
  <section id="DSPboard.requirements">
    <title>DSP Board Requirements and hardware selection</title>
    <para>For multiunit tetrode recording, the DSP Board must perform
    user-programmable digital filtering on the raw 32 ksps 10-channel
    data from the Acquisition board. Our signal processing
    requirements were as follows:
    </para>
    <itemizedlist>
      <listitem>
	<para> Processing speed: To perform 200-tap FIR filtering on
	each incoming sample would require 64 million
	multiply-accumulates per second -- we judged 200 coefficients
	to be the maximum conceivable length any user would need when
	filtering incoming data.
	</para>
      </listitem>
      <listitem>
	<para> Floating-point multiply-accumulate: Fixed-point DSP
	requires careful consideration, especially in the IIR case, to
	avoid instability and overflow. This level of attention to
	filter coefficient selection is undesirable in any system
	where end-users are performing filter design, as it requires
	detailed understanding of the various stages of processing
	quantization. Thus, all DSP operations must use floatin-point
	arithmatic.
	</para>
      </listitem>
      <listitem>
	<para> Open/inexpensive development tools: Any DSP we select
	needs to have inexpensive development tools, ideally ones that
	are Free Software. Since the bulk of DSP development will be
	performed in assembly, at the very least it would be ideal if
	a Free assembler existed.
	</para>
      </listitem>
      <listitem>
	<para> Ease of assembly: Due to the limited anticipated volume
	production, any DSP considered needs to be avialble in a
	hand-solderable (non-BGA) package</para>
      </listitem>
    </itemizedlist>
    
    </section>
    <section>
      <title>DSP Board Hardware</title>
      
      <para> The Analog Devices SHARC ADSP-21262 comes closest to
      meeting the DSP criteria. The 200 MHz 32-bit floating point DSP
      has an SIMD ALU allowing for up to 400 MMACS/second, and is
      available in a 144-pin LQFP package. The development tools
      (VisualDSP++) are expensive but available at a reduced price to
      academic institutions. To allow for processing overhead, we use
      two DSPs, one per tetrode.
      </para>
      
      <para> A Xilinx Spartan-3 XCS200 FPGA is used to decode the
      Acquisition Board optical data stream and pass it onto the DSPs,
      as well as providing the necessary buffering and interface to
      the Data Bus and Event Bus. </para>
      
      <section>
	<title>Interfaces</title>
	<para> Data Bus </para>
	<para> Event Bus </para>
	<section>
	  <title> Signals </title>
	  <para> The following single-wire signals allow the FPGA to
	  signal the DSP about various sytem events: </para>
	  <signaldef set="FPGA/DSP signals">
	    <signal> 
	      <name> SAMPLE </name>
	      <info> A rising edge on this line tells the DSP that a
	      new set of input samples is available from the
	      FPGA. Occurs roughly every 31.25 microseconds. </info>
	    </signal>
	    <signal>
	      <name> EVENTS </name>
	      <info> A high indicates there are events waiting to be
	      read in the FPGA's event bus queue. A successful
	      read-out of all pending events by the DSP causes this
	      line to go low. </info>
	    </signal>
	    <signal> 
	      <name> TINC </name>
	      <info> Timer increment: a rising edge on this line
	      signals the beginning of a new timestamp, every 100
	      microseconds. </info>
	    </signal>
	    <signal>
	      <name> TCLR </name>
	      <info> Clear timestamp counter. A high on this line
	      coupled with a rising edge on TINC causes the timestamp
	      counter to be reset to zero. </info>
	    </signal>
	  </signaldef>
	</section>
	  
	<section> 
	  <title>FPGA / DSP Interface </title>
	  <para> The ADSP supports several external serial interfaces,
	  as well as an asychronous 16-bit memory bus (the Parallel
	  Port), the latter being the only method with sufficient
	  bandwidth for our application. The ADSP-21262 automatically
	  performs 16-to-32bit packing and unpacking between the
	  Parallel Port and its internal memory, and is only able to
	  access the Parallel Port via Direct Memory Access
	  (DMA). </para>

	  <para> The external memory space is partitioned into five
	  application-specific 12-bit regions. Several of the regions
	  support a "transaction complete" address that, when written
	  or read, signals the FPGA that the necessary writes or reads
	  for that particular piece of data are complete.  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
	      0x0nnn: Status and  Data  Samples</para>
	      <para>This DSP-read-only region contains new sample data
	      and status information.</para>
	      <memmap title="Status and Data Samples">
		<addr a="0x0000"> Acquisition Board Status </addr>
		<addr a="0x0000" b="0:0"> STATUS, the status of the
		optical connection (1= link up)</addr>
		<addr a="0x0000" b="1:1"> TXERROR, fiber command
		transmit error. </addr>
		<addr a="0x0000" b="4:7"> CMDID, the most recent
		command ID</addr>
		<addr a="0x0000" b="8:11"> CMDSTS, the most recent
		command status</addr>
		<addr a="0x0001">Sample from channel 1</addr>
		<addr a="0x0002">Sample from channel 2</addr>
		<addr a="0x0003">Sample from channel 3</addr>
		<addr a="0x0004">Sample from channel 4</addr>
		<addr a="0x0005">Continuous data sample</addr>
		<addr a="0x0006">Debug value for read-testing, always equals 
		<addr>0x1234</addr>.
		</addr>
		<addr a="0x0007">The Event Bus ID assigned to this DSP</addr>
		
	      </memmap>
	    </listitem>

	    <listitem> 
	      <para> 0x2nnn: Output data buffer</para>
	      <para> This region allows for the full write of a data
	      frame destined for the Data Bus, with a maximum length
	      of 2048 bytes (1024 words).</para>
	      <memmap title="Output Data Buffer">
		<addr a="0x2000" b="7:0"> Data source ID.</addr>
		<addr a="0x2001" b="9:0"> Total length of frame N, in
		words.</addr>
		<addr a="0x2002 to (0x2000 + 2N)"> Frame data for an
		N-word frame.</addr>
	      </memmap>
	    </listitem>

	    <listitem>
	      <para> 0x4nnn: Event Output </para>
	      <para> A write of an Event Bus event to this region
	      queues it in the FPGA for transmission on the event
	      bus.</para> 
	      <memmap title="Event Output">
		<addr a="0x4000"> Event target addresses A15:A0 </addr>
		<addr a="0x4001"> Event target addresses A31:A16 </addr>
		<addr a="0x4002"> Event target addresses A47:A32 </addr>
		<addr a="0x4003"> Event command word </addr>
		<addr a="0x4004 to 0x4008"> Event data words, in increasing
		order </addr>
		<addr a="0x4009"> Event complete. Write this address
		to signal the completion of an Event write</addr>
		

	      </memmap>
	    </listitem>

	    <listitem>
	      <para> 0x6nnn : Event Input </para>
	      <para> The DSP can read new events from the Event Bus
	      here. </para>
	      <memmap title = "Event Input">
		<addr a="0x6000"> Event command word </addr>
		<addr a="0x6001 to 0x6005"> Event data words, in
		increasing order</addr>
		<addr a="0x6006"> A write here signals the FPGA that
		the DSP has finished reading this event. </addr>
	      </memmap>
	    </listitem>

	    <listitem>
	      <para> 0x8nnn: Acqboard interface </para>
	      <para> This region allows us to send commands to the
	      acquisition board. </para>
	      <memmap title="Acqboard Commands">
		<addr a="0x8000" b="3:0"> Acqboard Command </addr>
		<addr a="0x8001" b="2:0"> CMDID </addr>
		<addr a="0x8002" b="7:0"> Data Byte 0 </addr>
		<addr a="0x8002" b="15:8"> Data byte 1 </addr>
		<addr a="0x8003" b="7:0"> Data Byte 2 </addr>
		<addr a="0x8003" b="15:8"> Data byte 3 </addr>
		<addr a="0x8004"> A write here signals the FPGA that
		the buffer contains a new valid Acqboard command that
		is to be sent to the Acqboard.</addr>
	      </memmap>
	    </listitem>



</itemizedlist> </section> </section>
	      </section> </section> </article>
