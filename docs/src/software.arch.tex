Generic software architecture notes. We really want to separate out
dsp-specific functionality from non-DSP functionality.


\section{Signal Processing}

The DSP signal processing infrastructure is designed to allow the
connection of data sources (such as the continuous data from the
acquisition board) to Data Sinks (like a tetrode packetizer).

These connections occur via signal processing elements called Filter
Links. Each filter link is designed to provide a filtered (that is,
processed) link back to a single Data Source channel.  A Data Sink can
have as many Filter Links back to sources as are necessary for its
application. Note that each data source channel will typicall have
multiple associated Filter Links.

FilterLinks are generated by the Filter Link Manager, which is a
factory object which takes a single DataSource in its
constructor.

A FilterLink exposes a single method to its associated sink:
\texttt{nextSample()}, which returns the next available
\texttt{sample\_t} contingent on the current state of its associated
input.  \texttt{nextSample} also updates any internal state that the
FilterLink may keep about intermediate values, past-samples, etc.

Every data source and sink have an associted \texttt{sampleProcess()}
method.  This method is where all the per-sample processing should
occur for this component. \texttt{sampleProcess()} will be called for
all Data Sources before it will be caled for all Data Sinks().

Typically a DataSource uses its sampleProcess() method to read a new
set of samples off of the wire and place them in its internal
channels' circular buffers.

\subsection{Data Sources}
Each data source can have several input channels of data, these are
associated with SampleBuffers, which we pass to the
FilterLinkManager().

Every data source inherits from DataSourcBase, which has:

void sampleProcess()
int getChanNum()
sampleBuffer* getChannelBuffer(int i)
void onEvent(const Event & )
void readySample() -- is a sample ready? 


How do we know to run SampleProcess? query readySample()


\subsection{Filter Link Manager}
The FilterLink Manager is a factory method which returns a FilterLink to a requested DataSource channel. 

at start-up:
  flm = FilterLinkManager(DataSource ref) 
  
inside of a data sink: 

datasink::newLink()
   pFilterLink = flm->newLink(LinkType, DataSource.getChannelBuffer())


\subsection{Data Sink}
All Data Sinks inherit from DataSinkBase
they have: 
  void sampleProcess() = 0 
  void onEvent(const Event &) = 0


A typical data sink would have code in its sampleProcess() function
which would look as follows:

for(int i = 0; i < chanNum_; i++) {
   sample_t sample = filterLinks_[i]->nextSample(); 
   sampleBuffers_[i].pushBack(sample)
}

// do other stuff, such as packetize for output


\section{Metadata and control}
The Soma System is based around the EventBus, a low-latency
high-availability data bus. Devices on the event bus, such as a DSP,
communicate to other devices via the event bus by sending Events to
some subset of other devices.

Each event is six 16-bit big-endian words long, with the first word
consisting of an 8-bit command and an 8-bit source. Every device on
the event bus can place one Event on the bus per ECYCLE (20 us).

Partitoning the range of commands intelligently as the Event space
represents a sort of generic inter-device RPC mechanism, and may be
accessed by all maner of devices: general purpose processors, DSPs,
FPGAs, and devices on the network.


\section{Output} 
There are two types of system output: event and data. Event output
places events on the event bus; Data places data on the data bus.

Note that we can only send one Event per ECYCLE and roughly one Data
packet per ms. Data packets must be less than 600 bytes in length. All
values should be in network byte order, i.e. big-endian. 

For both event and data fifos, you: 

pDp = dataOutFifo.requstNew()
pDp.buffer []
pDp.commit()
