Design concerns and considerations for the DSP assembly. 


The loader is a whole 'nother bag of worms that we'll hopefully tackle when we're more familiar with the tools


Memory accesses: Please note that all memory accesses, including the following:
read_status
read_event
write_event
write_acqboard

and the entire
process_sample interrupt handler

all disable the SAMPLE (INT0) interrupt. This is to prevent an interrupt occuring during a DMA action and thus breaking the DMA (since there is only one set of PP DMA registers)



----------------------------------------------------------------------------
ADSP EXECUTION CYCLE
----------------------------------------------------------------------------

The ADSP normally runs a cycle where it checks for new events, processses them, and then writes out events. 

The interrupts either say "here's new data, process it" or 
The timestamp has changed

INT0: Increment timestamp, clear if FLAG3 = 1
INT1: New samples, process new chunk of data

FLAG2: poll to see if there are new events!


Event cycle ----------------------------
   DMA-in an event
   process event
   DMA-out any result
   perform any latent processing...stuff... (uhh, yea)

   this lets us be sure that, during the normal loop, we can send events


Data processing cycle ------------------
   For the tetrodes, to take advantage of SIMD, we have some interleaving-buffer issues, also which are present in the output data. 
   Chan 1&2 are stored in a single word space, interleaved
   Chan 3&4 are stored in a single word space, interleaved
   Chan C&C' are stored in a single word space, interleaved
   
   how to store outputs?
   obvious output buffers, sure -- but then how to DMA? parallel port can't do chained DMA... well, what we really want are 

      


Pcode pending interrupt for new samples:

there are global no-trigger and lookback values

Upon getting a trigger, we want to say:
   don't re-trigger for n samples; this can be degremented and checked every sample
   wait another m samples to record. 
   


1. DMA-in new samples, in 16-bit fixed-point twos-complement form. 
2. convert new samples into 32-bit FP and save at appropriate point in circular input buffers
2. Filter channels 1 - 4, 32-bit FP!
    FIR, using SIMD (thus in pairs), where we filter the max len, and
    we thus must make sure that the end of each filter is all 0s. 

2.5 save output in output circular buffers
3. Filter continuous channel
4. perform necessary down-sampling of continuous, by factor n (n=1,2,3,4, 5)
6. store in filter output

3. check for threshold crossings:
    decrement notrigger
    if notrigger >= 0 then
       notrigger--; 
    else
       for all channels: 
           if outvals[n - lookback] >= threshold  
              this is a spike! 
              capture and send the past SPIKESIZE packets
              // this creates latency issues, or something;
	      write buffer ADDR to _PENDING_SPIKE_buffer
	      notrigger := NOTRIGGER;  	      
           end if
    end if




7. transfer filter samples if there are enough of them, something something
8. done




Variable notes:

-- globals
TIMESTAMP: 32-bit int time stamp
MYID : tetrode number

NEWSAMPLES[5]: DMA target for input sample reading. 


--spike-specific --------------
#compile-time defines:
# SBUFSIZE: length of buffer, 1024 
# SHSIZE : length of fir filter, 256
# SYSIZE : length of output, 256

SPIKELEN : how many samples do we want to include when we capture a spike
POSTTRIGLEN : after a trigger, we want to see this many spikes
NOTRIGGERLEN: after getting a trigger, don't re-trigger for this number of samples
NOTRIGGER: counter; we only trigger when this is = 0, and each trigger reloads it with NOTRIGGERLEN. 

SX12[2*SBUFSIZE] : (dm) interleaved sample circular buffer of chan 1 & 2
SX34[2*SBUFSIZE] : (dm) interleaved sample circular buffer of chan 3 & 4
SH12[2*HSIZE] : (pm) interleaved impulse response of filter for chan 1 & 2
SH34[2*HSIZE] : (pm) interleaved impulse response of filter for chan 3 & 4
SY1[256] ..SY4[256] : (dm) output buffers, 32-bit
 

currentpos : current poisition in circular buffer for spike channels
SGAIN[4] : gains of each chan (8-bit int, actual gain / 100) 
SFID[4] : filter ID for each chan (16-bit int)
SHFID[4] : hardware filter setting (8-bit int)
STHRESH[4] : channel threshold (16-bit signed int); 


--Continuous-specific-----
CODOWNSAMPLE : downsample ratio. 
COX[1024] : direct circular buffer for EEG
COH[256] : (pm)  filter buffer
COY[512] : (dm) continuous circular output buffer
COGAIN : gain of continuous channel
COFID : filter ID for continuous channel
COHFID : hardware filter ID; 


--Acboard-specific--------
CMDSTS : previous command status
CMDID : most recent completed CMDID
CMDIDPENDING : pending CMDID
PENDINGACQCMD[2]  : pending acqboard event. 

DAG configuration:
DAG1[0] (i0) and DAG2[0] (i8) are for in-process mucking around

DAG1: (all circular) 

5: Spike interleaved input buffers 1 & 2
6: Spike interleaved input buffers 3 & 4
7: continuous input buffer

DAG2:
11: Continuous output buffer
12: Spike output buffer for channel 1
13: Spike output buffer for channel 2
14: Spike output buffer for channel 3
15: Spike output buffer for channel 4


All internal buffers are in 32-bit floating point. When we call a create_packet function, we perform the necessary fixed-point conversion via FIX. 

Since SIMD filtering is just SISD filtering with different pointers, we essentially use the same code for both. 

  


-----------------------------------------------------------------------------
EVENTS
-----------------------------------------------------------------------------

All events which modify signal processing parameters (Filter, gain, etc) cause a disable-flush-enable operation if you are in DATA mode, i.e. if interrupts are enabled. 


Event processing loop:
   read status byte
   if link status != previous link status
      send "the link is now up/down" event
      set previous link status = current status
      if link now down, disable SAMPLE interrupts
      CMDIDPENDING = -1; 
   end if
   if CMDIDPENDING >= 0 then (we're waiting to hear back from the acqboard)
      if CMDIDPENDING = new cmdid we just read from sample buffer then
         CMDID = CMDIDPENDING; 
         CMDIDPENDING = -1
         broadcast new event revealing our new state!
	 update relevant state variables
      else
         not done with the event yet! 
      end if; 
   end if; 

   if EVENTS = '1' then 
      read event, process it!
   end if; 
   

what if we have a 1-us timer? 
well, the problem there is that we could interrupt ourselves
i.e. if an event takes too long we abort it? or watchdog-like? 
but some events will be short, and some will be long

polling introduces jitter, which is bad. 

we need atomic reads of events, samples, etc. 

not just read; write too? ugh. 

all off-chip 





Generic configuration read and write : ---------------------------------

40 : Read config parameter
41 : write config parameter

 For writing, things are indicated above. For reading, we use the Target and Addr similarly, but return the data in a manner that makes sense (i.e. the similar data words) to the SOURCE device. 


write filter coefficients: 
    TARGET = 0x10 : FIR FILTER for spike channel 1
         0x11 : FIR FILTER for spike channel 2
	 0x12 : FIR FILTER for spike channel 3
	 0x13 : FIR FILTER for spike channel 4
	 0x14 : FIR FILTER for constant chan
    ADDR  =  coefficent number [0..255]
    DW0 = word that goes at ADDR, IEEE 32-bit foo
    DW1 = word that goes at ADDR+1, "

write filter lengths:
    TARGET = 0x20
    ADDR = filter length target (0 = spike 1, 3 = spike 4, 5 = cont)
    DW0[7:0] = length, unsigned int

write filter IDs:
    TARGET = 0x21
    ADDR = filter for chan
    DW0[15:0] = unique 16-bit filter ID

change spike parameters: 
    TARGET = 0x23 : spike length
       DW0[7:0] = unsigned spike length
    TARGET = 0x24 : notriggerlen
       DW0[7:0]   : length of no trigger period 
    TARGET = 0x25 : posttriglen
       DW0[7:0] : length of post-trigger period


change cont parms
    TARGET = 0x26 : downsampling ratio for continuous
         DW0[3:0]: downsampling ratio
    TARGET = 0x27 : number of samples to output per continuous frame
	 DW0[15:0] : actual number 




42: Enable spike acquisition interrupt
    flushes buffers, etc. 
43: disable spike acquisition interrupt
44 : events that change acq board settings:
// hardware parameters:
   when we're done changing a hardware parameter, we send a tetrode state broadcast event. Or something; still not quite sure. 
hardware parameters are funny. See, there could be some arbitrary amount of time between when we say "change" and when it actually changes; 

   if CMDPENDING < 0  then no pending events
      CMDPENDING = CMDID++
   else
      generate error!
   end if; 
      
   
   TARGET = 0x0 : channel gain on acq board
         ADDR = channel number
         DW0[3:0] = gain setting on board
   TARGET = 0x1 : HW filter on board
	 ADDR = channel number
         DW0[1:0] = channel 
   TARGET = 0x2 Input selection for continuous channel
	 DW0[1:0] = channel

   the resulting error will be set back to whoever sent this
   and we will give the target, addr, and command that failed
   with error "CMDPENDING"



every time the acqboard state changes, we send out a full broadcast frame with "updated acqboard state.
45: query acqboard settings



-----------------------------------------------------------------------------
BOOTING
-----------------------------------------------------------------------------
or, how to make my own loader kernel. 
We know that on startup, 1024 bytes (256 instruction words?) will be loaded into the device. 

Somewhat oddly, the docs seem to suggest that the reading actually begins externally at 0x000, and internally at 0x80000. So the loader really will have to over-write itself. 

But! but! 
we can do the following: essentially move the location of the loader kernel to the last 100 instructions in memory. This will of course be a total mindfuck for anyone who ever wants to use that space, but we make sure our linker won't let us put code there anyway. 

We will read in 

Note that all instructions here must be PC-relative, otherwise, ouch! 


1. load in kernel
2. kernel copies kernel to last 100 instructions (600 bytes) of program memory
3. transferrs control to there
4. reads in events to write various locations in memory
5. ?


To generate the DSP code we execute
elfspl12k.exe -ram -f b -pm -o DSPboard.stk DSPboard.dxe
where dxe is the executable format. 
