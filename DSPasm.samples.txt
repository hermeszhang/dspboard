---------------------------------------------------------------------------
DSPboard DSP code: SAMPLES
---------------------------------------------------------------------------

Register set: alternate


Pcode pending interrupt for new samples:

there are global no-trigger and lookback values

Upon getting a trigger, we want to say:
   don't re-trigger for n samples; this can be degremented and checked every sample
   wait another m samples to record. 

DECLARATIONS: --------------------------------------


Within, we'll be using the following DAGs:
DAG1: (all circular) 

5: Spike interleaved input buffers 1 & 2
6: Spike interleaved input buffers 3 & 4
7: continuous input buffer

DAG2:
11: Spike output buffer for channel 1
12: Spike output buffer for channel 2
13: Spike output buffer for channel 3
14: Spike output buffer for channel 4
15: Continuous output buffer


All internal buffers are in 32-bit floating point. 

When we call a create_packet function, we perform the necessary fixed-point conversion via FIX. 



Since SIMD filtering is just SISD filtering with different pointers, we essentially use the same code for both. 

spike buffers are interleaved to allow for SIMD. 
   

subroutines:

get_newsamples:
   DMA's in new samples into TMPNEWSMP; 
   
convert_newsamples
   converts new samples to floating point, as read by TMPNEWSMP
   converts them to floating point
   stores at head of each of the appropriate buffers
   Note that because of the way post-incrmeent addressing works, i13 will always point to the location _after_ the most recently written sample. 
   
filter_channels
  performs SIMD FIR filtering of channel 1/2, channel 3/4, and SISD
      filtering of continuous channel
   note that as convolution occurs with sum(x[n]h[k-n]), we need to reverse one
      vector. this is accomplished most easily by stepping _back_ through
      the samples buffer. 

threshold
   checks threshold crossing, and if it occurs, formats an output spike
   we actually look THRESHOLDLEN samples back for crossing; 
   if we are not in the no trigger phase and we get a spike, 
      we call create_spikepacket and set PENDINGOUTSPIKE = 1


check_continuous
   checks to see if contcnt samples have passed
   and if so, calls sample.create_continuous_packet

create_spikepacket:
   creates the spike packet in memory, to be DMA'd 
   called once; uses all 4 chans. 
   r0 = number of samples to use;    

create_spikepacket_chanel_data:
   formats an individual channel;
   

filter_fir:
   performs FIR filtering using 32-bit floating point on the buffer
   pointed to by i0/m0 and the filter i8.
   Designed to be friendly enough that we can SMID with a wrapper. 
filter_fir_simd:
   simple wrapper around filter_fir which 


send_spike_dma:
   DMAs out a spike, to the output data location.
   Does not block. 



1. DMA-in new samples, in 16-bit fixed-point twos-complement form. 
2. convert new samples into 32-bit FP and save at appropriate point in circular input buffers
2. Filter channels 1 - 4, 32-bit FP!
    FIR, using SIMD (thus in pairs), where we filter the max len, and
    we thus must make sure that the end of each filter is all 0s. 

2.5 save output in output circular buffers
3. Filter continuous channel
4. perform necessary down-sampling of continuous, by factor n (n=1,2,3,4, 5)
6. store in filter output

3. check for threshold crossings:
    decrement notrigger
    if notrigger >= 0 then
       notrigger--; 
    else
       for all channels: 
           if outvals[n - lookback] >= threshold  
              this is a spike! 
              capture and send the past SPIKESIZE packets
              // this creates latency issues, or something;
	      write buffer ADDR to _PENDING_SPIKE_buffer
	      notrigger := NOTRIGGER;  	      
           end if
    end if




7. transfer filter samples if there are enough of them, something something
8. done


