Perhaps miss-named "software" file to design our general layout for what the hell the FPGA does:

Memory addresses:
one address to write a command



To send a command to an acq board:
There's a memory address that the DSP writes the acqboard command to, to say, change gain. Then it can read and poll. The question is, how long should it poll?

well, it can only send one command per sample interval, obviously, and _at most_ that, as we have to wait for the other one. 

maybe each DSP will have a linked list of to-acqboard? or a queue or something like that? 

Every time an acqboard event is done, we send it. 

Even CMDID for one DSP, odd for another. FPGA partitions them out. 


how to read events, given they may be being written by the FPGA? need some sort of mutex or something. 

read events, put them in an event queue, and process the queue
append to an output queue of events

FPGA: circualr buffer? something like that? 


For booting: 
   The ADSP loads 256 32-bit words (1024 bytes) in 8-bit parallel mode (running very slowly) as the loader kernel
   We can map in 2 blockselect+ RAMs for this purpose


-----------------------------------------------------------------------------
EVENTS
-----------------------------------------------------------------------------
is it reasonable to have an event interface where each side of the buffer is half-duplex?

we're only going to be reading or writing the event bus, never both, esp if we don't read our own events. 

What about the other side? well, for a memory-related interface, that's correct

and writing events is so freaking fast!

We care because it would be nice to use just one buffer for this. 
seriously, though, that's queuing 14 events out, or 21 in. Hmm...

it's a decent design decision, and we'll make it.

At the same time, remember that the event buffer connected to the DSP is not the same as the event buffer that talks to the 

So, the problem is that each event is 6 cycles, right? so we can't actually take an event out fast enough, because we're heading it with the 3 words of "target" information. Hmm. 

So let's "clock this thing up" to, say, 60 MHz or something similar. Maybe even faster. This will result in us having to have the actual read and write interfaces cross a clock boundary, as well as the RAMs, but oh well. Plus, the ADSP memory interface side will probably be running at something close to this clockspeed anyway. 

since we will be getting a new event every cyle of the event bus, that means a new 6-cycle event every 6 SYSCLK ticks, or 18 internal clocks (internal clock > 3x sysclk). 

Arming an output event will take at least 9 ticks (3 for addr and 6 for data), and reading an input event at least 6 ticks.

how to determine our own address? 



What if we sample EVENT to check for events to read, write, and we do all on each cyle? 
    eliminates the acknowledge issues for reading
    reading takes 7 ticks, writing 10? ouch!
    This is going to require some creative, tight FSMing
    
    we get INPUT EVENTs 


Event Input:
    updated each input cycle
    EMINE == the most recent event was for me
    EVENT : registered inputs. This is delayed by 2 ticks (as is the final output register set) to deal with clock-transition issues
    use 16 SRLE-16s for registers, always shift in new addr bytes, just compare at the end. let's us be programmable!
       

Pipeline chart:
stage : 0   1   2   3   4   5   6   7   8   9   10   11   12  13  14  15
EVENT:  1   0	1   1	1   1	1   0	1   1	1    1	  1   0	  1   1
EVENTL: 1   1	0   1	1   1	1   1	0   1	1    1	  1   1	  0   1
CNT	x   x	x   0	1   2	3   4	5   0	1    2	  3   4	  5   0
DATA:	x   x	D01 D1	D2  D3	D4  D51	D02 D1	D2   D3	  D4  D52 D0  D1
DATAL	x   x	x   D0	D1  D2	D3  D4	D51 D02	D1   D2	  D3  D4  D52 D0
ADDR	x   x	A0  A1	A2  A3	A4  A5	A0  A1	A2   A3	  A4  A5  A0  A1
ADDRL	x   x	x   A0	A1  A2	A3  A4	A5  A0	A1   A2	  A3  A4  A5  A0
D0	x   x	x   x	D01 D01 D01 D01	D01 D01	D02  D02  D02 D02 D02 D02
D5	x   x	x   x	x   x	x   x	x   D51 D51  D51  D51 D51 D51 D52
for this one, myaddr: 0x20
SMINE	x   x   x   x   x   x   1   1   1   0   0    0	  0   0   0   0
MINE	x   x   x   x	x   x	x   x	x   1	0    0    0   0   0   0
EMINE   x   x	x   x	x   x	x   x	x   x	1    1	  1   1	  1   1


please note that the S/R latch for SMINE is very unusual in that the SET overrides the RESET


Event output:
    ADDR[3:0] : first 3 words are targets, next 6 are data
    just write straight in
    writing the last word(ADDR=8) arms
    wait for EVENTWDONE to be high before writing again. 
 

FSM notes:
   we have simple single-states for DSP reset and boot mode setting
   for an event (all events), we always write the first word to ram-- 
     this has no effect, as the addr should always be pointing to the next addr in the circular buffer
    Wow, this FSM is longer than I thought it would be. ouch. 


    

FPGA must be able to decode events initially, for booting, etc. 

FPGA receive the following events:
  boot
  boot byte
  reset time
  set board ID






DSP side of event-interface: ---------------------------
writing an event actually writes to a series of 9 registers, 



EVENT:
   CMD = 0x01 SENDER = any dw0[0] == new boot state
   CMD = 0x02 SENDER = any dw0[0] == state of DSP RESET pin
   CMD = 0x03 SENDER = any dw0 = addr of first word
			   dw1 = first word to write dw=4 last word of 4



   

------------------------------------------------------------------------------
FPGA main data FIFO
------------------------------------------------------------------------------
a "mode" bit:
   0 == normal operation as a data fifo
   1 == just acting as RAM

Signals:

Random access memory signals for booting and boot control:
RAIN[9:0] : random access address for input(writing)
RAOUT[10*:0] : random access address for output(reading) 
RDOUT[7:0] : random access data output
RDIN[15:0] : random access data input
RWE : ram write enable

instead of being the obvious fifo, we'll use 3 blockselect+ blocks to do a triple-buffered block appraoch. This will let us have 3 512-byte blocks. x2 dsps, still leaves enough for the 1 event each. 

to detect a done buffer: 
   we have a register (BUFEND) at location foo that gets written whenever the address == the address of the length field. Each "newbuffer" resets that register to 0xFFFF, i.e. "not gonna get written". We consier a frame "done" when ADDR = BUFEND and there's a write. 

buffer input side
BUFWE : write this byte
BUFADDRIN[7:0] : input address
BUFDIN[15:0] : input data to write
BUFERROR : occurs when we are in state AWAIT, and try to do a WE


buffer outputs:
BUFDOUT[15:0] : output data
BUFNEXT: input to say "gimme the next frame"
BUFACKOUT : high when BUFDOUT is a valid byte. 

the output of this system is very similar to what's needed to talk to the data bus, to modularize that functionality and save myself some work. 


CLKA : clock on the DSP side
CLKB : clock on the data bus side

For internal data frames, the "length" argument is 2-byte words, always includes the total frame length, and is preceeded by a 1-word header that looks like:

bits 5:0 : source ID (tetrode number
bit 7:6 : type (spike/eeg) spike = 0, eeg = 1
bit 15:7 : total length of frame in 2-byte words (0 == 256 == 512b)






 





------------------------------------------------------------------------------
ADSP EXTERNAL MEMORY INTERFACE
------------------------------------------------------------------------------
The ADSP will do 16/32 packing. It seems smarter to pack 16-bit words on our side, i.e. for separate 16-bit values 0xAB and 0xCD, we send 0xABCD instead of 0x00AB and 0x00CD. The later takes four reads, the former two, and it's a lot easier once inside the DSP to split them. This isn't _always_ the case, mind you, but in general will be the .plan. 

For external accesses, then, we need to remember that we're really accessing 32-bit values. We use the notion L to denote the low word and H to denote the high word. 

The external memory space is partitioned into "regions", which begin on a 12-bit boundary. Hey, memory space is cheap :) However, parallel port doesn't support chaining. fuckers. 



Region	Use:
	memory addr : FPGA addr
0x0	this is the DMA-at-the-beginning-of-each-cycle word, along with metadata
	0x0000 : 0x0000 : metadata, i.e. are we connected, 
			  this sample was  bad, etc. 
	0x0001L: 0x0001 : sample from channel 0
	0x0001H: 0x0002	: sample from channel 1
	0x0002L: 0x0003 : sample from channel 2
	0x0002H: 0x0004 : sample from channel 3
	0x0003L: 0x0005 : sample from continuous channel

0x1	0x1000 : 0x2000 : Output data buffer
		
0x2	outbound events : write an event here:
	0x2000L: 0x4000 : low set of targets
	0x2000H: 0x4001 : medium set of targets
	0x2001H: 0x4002 : high set of targets
	0x2002L: 0x4003 : cmd word
	0x2002H: 0x4004 : first word
	0x2003L: 0x4005 : second word
	0x2003H: 0x4006 : third word
	0x2004 : 0x4007 : next 2 words
	0x2005 : 0x4008 : a write here "commits" the event 
			  to the event out buffer

0x3	inbound events:
	0x3000L: 0x6000 : cmd word
	0x3000H: 0x6001 : first word
	0x3001 : 0x6002 : next two words
		 0x6003
	0x3002 : 0x6004 : next two words
		 0x6005 : next two words
	0x3003 : 0x6006 : a read here says "i'm done reading this event"

0x4     acqboard control interface
	0x4000 : 0x8000 : status word
	0x4010L: 0x8020 : command (bits 3:0)
	0x4010H: 0x8021 : cmdid (bits 2:0)
	0x4011L: 0x8022 : command words :
		 0:7 one
		 8:15 two
	0x4011H: 0x8023 : command words :
		 0:7 thee
		 8:15 four
	0x4012L: 0x8024 : complete the CMD, i.e. send



Booting occurs in 8-bit mode, which uses the ALE cycle to put the 16 MSBs of a 24-bit address on the line. Thus during boot, we see ADDR on the FPGA == 0x0800. 
------------------------------------------------------------------------------
FPGA FIBER RX / TX
------------------------------------------------------------------------------

We want to be able to receive command updates, send commands, and send an event when there are lots of errors, or something like that. 

How do we tell the difference between "lots of errors" and "no cable connected"?
Solution: you don't. Every error you get triggers a "disconnected" state

You only reconnect when you get two straight frames of no error. 

the transition from disconnected to connected causes us to generate an event, but we'll let the DSP (which is polling the connected bit) handle that. 

we just read in bytes, count up
if we get an error, reset counter, change status from sync to nosync
dsp flushes buffers


Normally, the command interface just sends out frames full of zeros. But should it get a command, it will write it out once. 

We just do this as a big FSM, which is conditioned on OUTBYTE. Simple stuff. 

CLK8 is an 8 MHz CLKEN, and OUTBYTE = 10x CLK8



      



	
-----------------------------------------------------------------------------
FPGA interface to Acq Board
-----------------------------------------------------------------------------
Need some way of partitioning the events as they come in
some way of passing updated cmd bytes to the dsp
some way of interpreting the writes to the cmd word as, well, commands



----------------------------------------------------------------------------
ADSP EXECUTION CYCLE
----------------------------------------------------------------------------

The ADSP normally runs a cycle where it checks for new events, processses them, and then writes out events. 

We can use a circular buffer for pending events. the Pcode is:

if eoutHead != eoutTail
   send all events
end if

if EventWaitingFlag = '1' then
   read in event
   process event 
     change gain, modify filter, whatever
      possibly add output event
end if

INT 0 : 
   triggers increment of sample time counter
   this can be cleared by the appropriate event

INT 1:
   new sample loop
   read in new samples
   check to see if there is pending output data

   process the samples, perform filtering, yadda yadda
   if criteria meets foo, process output samples
   begin dma write of output

   

so, of our four flags we have:
   new sample (INT1)
   time inc (INT0)
   time clear
   new event
   
      
