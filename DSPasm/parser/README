== Introduction ==

=== Goal ===

To write a basic function checker for DSP assembly.  The parser should work only for basic registers - r0, r1, ... r32, i0, ... i32, m0, ... m32.  The checker should take in appropriately commented assembly code and check whether or not all inputs are used, all outputs are set, and whether all modified variables are indeed modified.

== Dependecies ==

ParseDSP.py used SimpleParse, which in turn depends on mxTextTools (egenix-mx).

== Running ==

To run ParseDSP, type:

python ParseDSP.py filename [filename]...

== Syntax ==

An assembly file consists of unused header information (such as include statements), and pairs of function headers and bodies.  Thus a typical file has the structure:

unused header

function pair - function A header
              \ function A body

function pair - function B header
              \ function B body

etc.

The start of a function header string is /*-.  The end of a header string is an arbritrary number of dashes followed by -*/.  Do not use /*- anywhere else in the document - /* with */ are valid elsewhere without nearby dashes, however.  Within the header the function name is the first string without whitespace before the first colon or semi-colon.  Function names may not contain any of /, *, -, ;, or :.

Function pairs are composed of a header and a body.  The header contains all relevant variable information and the body contains the function assembly code.  The body can be further decomposed into "statements".  The parser decomposes an assembly file into a list of "function dictionaries" based on the header and body contents.  The dictionaries contain the important data for functions - what the function takes as input, as output, what variables are modified, the function body, the function name, other functions called and associated comments.

Variables must be comma seperated lists of registers.  :, = and whitespace without a comma are comment delimiters.  Variable names may not contain /, :, =, * or - characters.  The input variables are a list of variables between the phrases "inputs:" and "outputs:".  The output variables are a list of variables between the phrases "outputs:" and "modifies:".  The modified variables are a list of variables between the phrase "modifies:" and the end of the comment.  The function body is the string located between the header and the next header.  A file may contain arbritrary information before the start of the first function.

=== Example ===

A function and the associated function dictionary are shown below.
{{{
/*--------------------------
function_name:
  comments
  rest of line is still comments inputs outputs modifies :
  comments

  inputs:
    r0, r1 , r2 are here 
    r5 , r6 are here, lalala
    r3 : lalalala
    r4 = lalalala
  outputs:
    r0 with this as a comment
    r1, r2 = stuff stuff lalala
  modifies:
    r3, r4
--------------------------*/
function_name:
  r3 = r1 + r2
  r4 = r0 + r3
  r0 = r4
}}}

This code has the following function dictionary:
{{{
{'name':'function_name',
 'comments':'comments inputs outputs modifies\ncomments\ncomments',
 'input_txt':'    r0, r1 , r2 are here \n  r5 , r6 are here, lalala \n    r3 : lalalala \n    r4 = lalalala',
 'ireg':['r0','r1','r2'],
 'output_txt':'    r0 with this as a comment\n    r1, r2 = stuff stuff lalala',
 'oreg':['r0'],
 'modifies_txt':'r3,r4',
 'mreg':['r3','r4'],
 'body_txt':'r3 = r1 + r2\nr4 = r0 + r3\nr0 = r4\n',
 'calls':[]}
}}}
The whitespace in comments may vary.  The parser attempts to preserve whitespace and newlines but makes no guarantees.

== Parser Algorithm ==

=== Parsing ===

The parser works in several iterations.

The parser begins by decomposing all function pairs into function header information and a function body.  The function header is parsed for input, output and modifies register strings, and stores them with keys input_txt, output_txt and modifies_txt.  The function body is preserved and stored.

{{{
{'name':'function_name',
 'input_txt':'    r0, r1 , r2 are here \n  r5 , r6 are here, lalala \n    r3 : lalalala \n    r4 = lalalala',
 'output_txt':'    r0 with this as a comment\n    r1, r2 = stuff stuff lalala',
 'modifies_txt':'r3,r4',
 'body_txt':'r3 = r1 + r2\nr4 = r0 + r3\nr0 = r4\n',
}
}}}

The next iteration parses the values associated with the various various foo_txt keys, making the keys ireg, oreg, mreg, qreg and sreg for input, output, modified, queried and set registers.

The next iteration checks that all variables mentioned as inputs, outputs or modified are used appropriately.  All inputs are checked to be explicitly queried in the function or explicitly queried by called functions.  All outputs and modified variables are checked to be explicitly set in the function or explicitly set by a called function.

Next all explicitly set variables are checked to be in either the output or modified list.  All queried variables are checked to be in at least one of input, output or modified.  A list of set but unlisted variables is created, along with a list of queried but unlisted variables.

For each function, a list of warnings is printed about whether variables are listed appropriately.

Finally, if nothing has gone too wrong, a success message is printed and the parser quits.

== Implementation ==

For the parser, I found a decent page listing parsers at http://www.nedbatchelder.com/text/python-parsers.html.  The parser uses simpleParse with an EBNF grammar.

=== Issues ===

When an register is modified/set by a called function, this modification is not included in the modification for the current function.  This is because low-level functions may be required to reset a program, and calling a main loop from a low level function will result in meaningless information.  The parser is meant as a high-level check on making sure the programmer knows what is being set within the function.
